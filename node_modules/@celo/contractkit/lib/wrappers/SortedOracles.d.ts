import { Address, CeloTransactionObject } from '@celo/connect';
import BigNumber from 'bignumber.js';
import { Branded } from 'io-ts';
import { CeloToken } from '../base';
import { SortedOracles } from '../generated/SortedOracles';
import { BaseWrapper } from './BaseWrapper';
export declare enum MedianRelation {
    Undefined = 0,
    Lesser = 1,
    Greater = 2,
    Equal = 3
}
export interface SortedOraclesConfig {
    reportExpirySeconds: BigNumber;
}
export interface OracleRate {
    address: Address;
    rate: BigNumber;
    medianRelation: MedianRelation;
}
export interface OracleTimestamp {
    address: Address;
    timestamp: BigNumber;
    medianRelation: MedianRelation;
}
export interface OracleReport {
    address: Address;
    rate: BigNumber;
    timestamp: BigNumber;
}
export interface MedianRate {
    rate: BigNumber;
}
export declare type CurrencyPairIdentifier = Branded<Address, 'PairIdentifier'>;
/**
 * Used to construct the pair identifier from a pair label (e.g. CELO/BTC)
 * The pair identifier needs to be a valid ethereum address, thus we
 * truncate a keccak of the pair label.
 * This function returns a branded type which can be fed into the wrapper.
 * @param pair a string
 */
export declare const pairIdentifier: (pair: string) => Branded<string, "PairIdentifier">;
/**
 * This will act as an enum of common pairs.
 * We can't use a straight enum because we want the value
 * to be a ReportTarget
 *
 * E.g. usage: sortedOracles.getRates(OracleCurrencyPair.CELOBTC)
 */
declare type defaultPairs = 'CELOBTC' | 'CELOUSD';
export declare const OracleCurrencyPair: Record<defaultPairs, ReportTarget>;
export declare type ReportTarget = CeloToken | CurrencyPairIdentifier;
/**
 * Currency price oracle contract.
 */
export declare class SortedOraclesWrapper extends BaseWrapper<SortedOracles> {
    /**
     * Gets the number of rates that have been reported for the given target
     * @param target The ReportTarget, either CeloToken or currency pair
     * @return The number of reported oracle rates for `token`.
     */
    numRates(target: ReportTarget): Promise<number>;
    /**
     * Returns the median rate for the given target
     * @param target The ReportTarget, either CeloToken or currency pair
     * @return The median exchange rate for `token`, expressed as:
     *   amount of that token / equivalent amount in CELO
     */
    medianRate(target: ReportTarget): Promise<MedianRate>;
    /**
     * Checks if the given address is whitelisted as an oracle for the target
     * @param target The ReportTarget, either CeloToken or currency pair
     * @param oracle The address that we're checking the oracle status of
     * @returns boolean describing whether this account is an oracle
     */
    isOracle(target: ReportTarget, oracle: Address): Promise<boolean>;
    /**
     * Returns the list of whitelisted oracles for a given target
     * @param target The ReportTarget, either CeloToken or currency pair
     * @returns The list of whitelisted oracles for a given token.
     */
    getOracles(target: ReportTarget): Promise<Address[]>;
    /**
     * Returns the report expiry parameter.
     * @returns Current report expiry.
     */
    reportExpirySeconds: () => Promise<BigNumber>;
    /**
     * Returns the expiry for the target if exists, if not the default.
     * @param target The ReportTarget, either CeloToken or currency pair
     * @return The report expiry in seconds.
     */
    getTokenReportExpirySeconds(target: ReportTarget): Promise<BigNumber>;
    /**
     * Checks if the oldest report for a given target is expired
     * @param target The ReportTarget, either CeloToken or currency pair
     */
    isOldestReportExpired(target: ReportTarget): Promise<[boolean, Address]>;
    /**
     * Removes expired reports, if any exist
     * @param target The ReportTarget, either CeloToken or currency pair
     * @param numReports The upper-limit of reports to remove. For example, if there
     * are 2 expired reports, and this param is 5, it will only remove the 2 that
     * are expired.
     */
    removeExpiredReports(target: ReportTarget, numReports?: number): Promise<CeloTransactionObject<void>>;
    /**
     * Updates an oracle value and the median.
     * @param target The ReportTarget, either CeloToken or currency pair
     * @param value The amount of `token` equal to one CELO.
     */
    report(target: ReportTarget, value: BigNumber.Value, oracleAddress: Address): Promise<CeloTransactionObject<void>>;
    /**
     * Updates an oracle value and the median.
     * @param value The amount of US Dollars equal to one CELO.
     */
    reportStableToken(value: BigNumber.Value, oracleAddress: Address): Promise<CeloTransactionObject<void>>;
    /**
     * Returns current configuration parameters.
     */
    getConfig(): Promise<SortedOraclesConfig>;
    /**
     * @dev Returns human readable configuration of the sortedoracles contract
     * @return SortedOraclesConfig object
     */
    getHumanReadableConfig(): Promise<{
        reportExpiry: string;
    }>;
    /**
     * Helper function to get the rates for StableToken, by passing the address
     * of StableToken to `getRates`.
     */
    getStableTokenRates: () => Promise<OracleRate[]>;
    /**
     * Gets all elements from the doubly linked list.
     * @param target The ReportTarget, either CeloToken or currency pair in question
     * @return An unpacked list of elements from largest to smallest.
     */
    getRates(target: ReportTarget): Promise<OracleRate[]>;
    /**
     * Gets all elements from the doubly linked list.
     * @param target The ReportTarget, either CeloToken or currency pair in question
     * @return An unpacked list of elements from largest to smallest.
     */
    getTimestamps(target: ReportTarget): Promise<OracleTimestamp[]>;
    getReports(target: ReportTarget): Promise<OracleReport[]>;
    private findLesserAndGreaterKeys;
    private toCurrencyPairIdentifier;
}
export {};
